// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`alias.js 1`] = `
"type t = string as 'x
type t = ((string, float) => unit) as 'x
type t = ((string, float) => unit) as 'x
type t = (string, float) => (unit as 'x)
"
`;

exports[`any.js 1`] = `
"type t = _
type t = node<_>

type t = {name: _}
type t = {name: @attr _}

type t = Plant(_)
type t = Plant(@attr _)

type t = (_, _) => unit
type t = (@attr _, @attr _) => unit

let x: _ = ()
let x: @attr _ = ()

external foo: _ = \\"foo_c_binding\\"
external foo: @attr _ = \\"foo_c_binding\\"
"
`;

exports[`arrow.js 1`] = `
"type t = (string, string) => string
type t = (~firstName: string, ~lastName: string) => string
type t = (~firstName: string=?, ~lastName: string=?) => string

type t = (
  string,
  string,
  superLongIdentifierHere,
  superLongIdentifierHere,
  superLongIdentifierHere,
) => okok

type t = (
  ~firstName: string,
  ~lastName: string,
  ~long: superLongIdentifierHere=?,
  ~long2: superLongIdentifierHere=?,
  ~long3: superLongIdentifierHere=?,
) => string

type t = (
  _,
  typeConstr<'a, state, 'foo>,
  'x as 'y,
  module(S),
  %extension,
) => string

external c_binding: (
  string,
  string,
  superLongIdentifierHere,
  superLongIdentifierHere,
  superLongIdentifierHere,
) => okok = \\"c_binding_external_primitive\\"

external c_binding: (
  ~any: _,
  string,
  ~firstClassModule: module(Hashmap with
    type key = string
    and type value = int
    and type superLongThingHere = definitelyLineBreak
  )=?,
  ~typeConstr: typeConstr<
    superLongIdentifierHere,
    superLongIdentifierHere,
    superLongIdentifierHere,
  >,
  ~subArrow: (
    ~subArrow: 'a1,
    ~subArrowParameter: 'a2,
    ~subArrowParameter3: loooooooongTypExpr,
  ) => (foo, bar, baz),
  ~subArrow2: (
    ~subArrow: 'a1,
    ~subArrowParameter: 'a2,
    ~subArrowParameter3: loooooooongTypExpr,
  ) => (
    foo,
    bar,
    baz,
    veryLooooooooooooooooongTupleTypeHere,
    veryLooooooooooooooooongTupleTypeHere,
    shoulBreakThatLine,
  ),
  ~jsObject: {
    \\"name\\": string,
    \\"otherLongName\\": evenLongerType,
    \\"woooooooooooooo\\": excitingTypeHereBecauseItWillBreakthatLine,
  }=?,
) => okok = \\"c_binding_external_primitive\\"

type t = (
  ~firstName: string,
  ~lastName: string,
) => {
  \\"name\\": string,
  \\"age\\": int,
  \\"moreProps\\": superLongIdentifierHere,
  \\"moreProps2\\": superLongIdentifierHere2,
  \\"moreProps3\\": superLongIdentifierHere3,
  \\"moreProps4\\": superLongIdentifierHere4,
}

type t = (
  ~firstName: string,
  ~lastName: string,
) => (
  name,
  string,
  age,
  int,
  moreProps,
  superLongIdentifierHere,
  moreProps2,
  superLongIdentifierHere2,
  moreProps3,
  superLongIdentifierHere3,
  moreProps4,
  superLongIdentifierHere4,
)

type t = (
  ~firstName: string,
  ~lastName: string,
) => typeConstr<
  name,
  string,
  age,
  int,
  moreProps,
  superLongIdentifierHere,
  moreProps2,
  superLongIdentifierHere2,
  moreProps3,
  superLongIdentifierHere3,
  moreProps4,
  superLongIdentifierHere4,
>

type t = (
  ~firstName: string,
  ~lastName: string,
) => module(Hashmap with
  type key = string
  and type value = int
  and type superLongThingHere = definitelyLineBreak
)

type t = (@attr string, @attr float) => unit
type t = (@attr @attr2 string, @attr @attr2 float, @attr3 int) => unit

type t = @attr (string => unit)
type t = @attr (foo, bar, baz) => unit
type t = @attr (foo, @attr2 ~f: bar, @attr3 ~f: baz) => unit

type t = @attr (string => @attr (int => unit))
type t = @attr (string, int) => @attr (int, float) => unit
type t = @attr (int => @attr (int, float) => @attr (unit, unit) => unit)
type t = (@attr @attr2 ~f: int, @attr3 ~g: float) => unit

type f = (
  @attr @attr @attr @attr @attr @attr @attr @attr @attr ~f: superLong,
  @attr2
  @superLongAttributeNameSuperLongsuperLongAttributeName
  @attr2
  @superLongAttributeNameSuperLongsuperLongAttributeName
  ~g: wowwwThisisLonggggg,
  @attr3 ~h: ccccrazysldkfjslkdjflksdjkf=?,
) => unit

type t = @attr (
  stringWithSuperLongIdentifierNameLoooooooooooooooooooooooooooooooooooooooooooooong => @attr2 (
    floatWithSuperLongIdentifierNameLoooooooooooooooooooooooooooooooooooooooooooooong => @attr3 (
      intWithSuperLongIdentifierNameLoooooooooooooooooooooooooooooooooooooooooooooong => unitWithSuperLongIdentifierNameLoooooooooooooooooooooooooooooooooooooooooooooong
    )
  )
)

type t = @attr (
  fooWithSuperLongIdentifierNameLoooooooooooooooooooooooooooooooooooooooooooooong,
  barWithSuperLongIdentifierNameLoooooooooooooooooooooooooooooooooooooooooooooong,
  bazWithSuperLongIdentifierNameLoooooooooooooooooooooooooooooooooooooooooooooong,
) => @attr2 (
  stringWithSuperLongIdentifierNameLoooooooooooooooooooooooooooooooooooooooooooooong,
  floatWithSuperLongIdentifierNameLoooooooooooooooooooooooooooooooooooooooooooooong,
) => unit

type t = @attr
@attrWithSuperLongIdentifierNameLoooooooooooooooooooooooooooooooooooooooooooooong
@attrWithSuperLongIdentifierNameLoooooooooooooooooooooooooooooooooooooooooooooong (
  fooWithSuperLongIdentifierNameLoooooooooooooooooooooooooooooooooooooooooooooong,
  barWithSuperLongIdentifierNameLoooooooooooooooooooooooooooooooooooooooooooooong,
  bazWithSuperLongIdentifierNameLoooooooooooooooooooooooooooooooooooooooooooooong,
) => @attr2
@attrWithSuperLongIdentifierNameLoooooooooooooooooooooooooooooooooooooooooooooong
@attrWithSuperLongIdentifierNameLoooooooooooooooooooooooooooooooooooooooooooooong (
  stringWithSuperLongIdentifierNameLoooooooooooooooooooooooooooooooooooooooooooooong,
  floatWithSuperLongIdentifierNameLoooooooooooooooooooooooooooooooooooooooooooooong,
) => unit

external debounce: (int, @meth unit) => unit = \\"debounce\\"

external debounce: int => @meth (unit => unit) = \\"debounce\\"

external debounce: (int, @meth (unit => unit)) => @meth (unit => unit) =
  \\"debounce\\"

external debounce: (
  int,
  @meth (unit => unit),
  @meth (unit => unit),
) => @meth (unit => unit) = \\"debounce\\"

external debounce: (
  int,
  @meth (unit => unit),
  @meth (unit => @meth (unit => unit)),
) => @meth (unit => unit) = \\"debounce\\"

type returnTyp = (int, int) => @magic float
type returnTyp = (
  intWithSuperLongIdentifierNameLoooooooooooooooooooooooooooooooooooooooooooooong,
  intWithSuperLongIdentifierNameLoooooooooooooooooooooooooooooooooooooooooooooong,
) => @magic float
type returnTyp = (
  intWithSuperLongIdentifierNameLoooooooooooooooooooooooooooooooooooooooooooooong,
  intWithSuperLongIdentifierNameLoooooooooooooooooooooooooooooooooooooooooooooong,
) => @magic
@magicWithSuperLongIdentiefierNameLoooooooooooooooooooooooong
@magicWithSuperLongIdentiefierNameLoooooooooooooooooooooooong
float

// uncurried
type t = (. int) => int
type t = (. int, int) => int
type t = (. int, . int) => int
type t = (. int, int, . int, int) => int

type t = (. @attr int) => unit
type t = (. @attr int, . @attr2 int) => unit
type t = (
  . @attrOnInt int,
  @attrOnInt int,
  . @attrOnInt int,
  @attrOnInt int,
) => int
type t = (. @attr ~x: int, ~y: int, . @attr ~z: int, @attr ~omega: int) => unit

@val
external requestAnimationFrame: (float => unit) => unit =
  \\"requestAnimationFrame\\"
@val
external requestAnimationFrame: @attr ((float => unit) => unit) =
  \\"requestAnimationFrame\\"

type arrows = (int, (float => unit) => unit, float) => unit

// tuple as single parameter
let prepare_expansion: ((type_expr, type_expr)) => (type_expr, type_expr) = f

type getInitialPropsFn<'a> = {
  \\"query\\": Js.Dict.t<string>,
  \\"req\\": Js.Nullable.t<Js.t<'a>>,
} => Js.Promise.t<Js.t<'a>>

// keep parens
external fromPoly: ([> ] as 'a) => t = \\"%identity\\"

external fromPoly: ([> ] as 'a, [> ] as 'b) => t = \\"%identity\\"
"
`;

exports[`bsObject.js 1`] = `
"type user = {\\"age\\": int}
type user = {\\"age\\": int, \\"name\\": string}
type user = {
  \\"age\\": int,
  \\"name\\": string,
  \\"moreFields\\": veryVeryVeryLongtype,
  \\"superLongNameThat\\": whyDoesATypeWithThisAmountOfCharactersMakeItIntoThisFile,
  \\"because\\": testingLineBreaks,
}

type magic = {..}
type t = {..\\"age\\": int}
type magicallyLong = {..
  \\"age\\": int,
  \\"name\\": string,
  \\"moreFields\\": veryVeryVeryLongtype,
  \\"superLongNameThat\\": whyDoesATypeWithThisAmountOfCharactersMakeItIntoThisFile,
  \\"because\\": testingLineBreaks,
}

external test: (
  foo,
  bar,
  baz,
) => {..
  \\"age\\": int,
  \\"name\\": string,
  \\"moreFields\\": veryVeryVeryLongtype,
  \\"superLongNameThat\\": whyDoesATypeWithThisAmountOfCharactersMakeItIntoThisFile,
  \\"because\\": testingLineBreaks,
} = \\"primitive\\"

// attributes
type user = @attr {\\"age\\": @attr int}
type magic = @attr {..}
type magic = @attr {.}
type t = @attr {..\\"age\\": int}

external test: (
  foo,
  bar,
  baz,
) => @attr
{..
  \\"age\\": int,
  \\"name\\": string,
  \\"moreFields\\": veryVeryVeryLongtype,
  \\"superLongNameThat\\": whyDoesATypeWithThisAmountOfCharactersMakeItIntoThisFile,
  \\"because\\": testingLineBreaks,
} = \\"primitive\\"

type t = {.}
type t = private {.}

type t = constr<{.}, {.}, {.}>
type t = {hr: React.component<{.}>}
"
`;

exports[`exoticIdent.js 1`] = `
"type s = \\\\\\"type\\"
type s = '\\\\\\"type\\"
type s = \\\\\\"module\\" as '\\\\\\"type\\"

type s = (~\\\\\\"let\\": \\\\\\"type\\") => \\\\\\"module\\"

type t = (\\\\\\"let\\", \\\\\\"module\\", \\\\\\"type\\")

type t = Foo.list<a>
type t = Foo.\\\\\\"let\\"<\\\\\\"let\\", \\\\\\"module\\">

let f: 'a. \\\\\\"let\\" => \\\\\\"type\\" = ()
"
`;

exports[`extension.js 1`] = `
"type t = %extension
type t = @attr %extension

external foo: %extension = \\"primitive\\"
external foo: @attr %extension = \\"primitive\\"

let x: %extension = z
let x: @attr %extension = z
"
`;

exports[`firstClassModule.js 1`] = `
"type t = module(S)
type t = module(Hashmap with type key = string)
type t = module(Hashmap with type key = string and type value = int)
type t = module(Hashmap with
  type key = string
  and type value = int
  and type superLongThingHere = definitelyLineBreak
)

type t = constr<module(S)>

external foo: module(S) = \\"primitive\\"

let x: module(S) = y

let x: module(Hashmap with
  type key = string
  and type value = int
  and type superLongThingHere = definitelyLineBreak
) = y

type toValueLikeInstance = t<'a> => module(RxValueLikeInstance.S with
  type a = 'a
)
type t<'a> = module(Test with type a = 'a)
type t = ref<module(Console)>

let devices: Hastbl.t<string, module(DEVICE)> = xyz

// attributes
type t = @attr module(S)
external foo: @attr module(S) = \\"primitive\\"
let devices: @attr Hastbl.t<string, module(DEVICE)> = xyz
"
`;

exports[`objectTypeSpreading.res 1`] = `
"type a = {\\"x\\": int}
type u = {...a, \\"u\\": int}
type v = {\\"v\\": int, ...a}
type w = {\\"j\\": int, ...a, \\"k\\": int, ...v}

type t = {...a, \\"u\\": int} as 'a
type t = {...a, \\"u\\": int} => unit
type t = ({...a, \\"u\\": int} as 'a) => unit
type t = ({...a, \\"u\\": int}, {...a, \\"v\\": int}) => unit

type user = {\\"name\\": string}

let steve: {...user, \\"age\\": int} = {\\"name\\": \\"Steve\\", \\"age\\": 30}
let steve = ({\\"name\\": \\"Steve\\", \\"age\\": 30}: {...user, \\"age\\": int})
let steve = {({\\"name\\": \\"Steve\\", \\"age\\": 30}: {...user, \\"age\\": int})}

let printFullUser = (steve: {...user, \\"age\\": int}) => Js.log(steve)
let printFullUser = (~user: {...user, \\"age\\": int}) => Js.log(steve)
let printFullUser = (~user: {...user, \\"age\\": int}) => Js.log(steve)
let printFullUser = (~user=steve: {...user, \\"age\\": int}) => Js.log(steve)

@val
external steve: {...user, \\"age\\": int} = \\"steve\\"

let makeCeoOf30yearsOld = (name): {...user, \\"age\\": int} =>
  {\\"name\\": name, \\"age\\": 30}

type optionalUser = option<{...user, \\"age\\": int}>
type optionalTupleUser = option<({...user, \\"age\\": int}, {...user, \\"age\\": int})>
type constrUser = myTypeConstructor<
  {...user, \\"age\\": int},
  {...user, \\"age\\": int},
>

type taggedUser =
  | User({...user, \\"age\\": int})
  | Ceo({...user, \\"age\\": int, \\"direction\\": bool}, {...salary, \\"taxFraud\\": bool})

type polyTaggedUser = [#User({...user, \\"age\\": int})]
type polyTaggedUser2 = [
  | #User({...user, \\"age\\": int})
  | #Ceo(
    {...user, \\"age\\": int, \\"direction\\": bool},
    {...salary, \\"taxFraud\\": bool},
  )
]
"
`;

exports[`polyTyp.js 1`] = `
"external getLogger: unit => {
  \\"log\\": 'a => unit,
  \\"log2\\": 'a. int => int,
  \\"log3\\": 'a 'b. ('a, 'b) => int,
} = \\"./src/logger.mock.js\\"

// polytype in label_declaration doesn't have attributes
type reducer<'state> = {
  state: @attr 'state,
  send: 'action. @attr ('state, 'action) => 'action,
}
"
`;

exports[`tuple.js 1`] = `
"type t = (string, int, float)

type t = (
  superLongTypeNameThatWillBreak,
  superLongTypeNameThatWillBreak,
  superLongTypeNameThatWillBreak,
  superLongTypeNameThatWillBreak,
  superLongTypeNameThatWillBreak,
  superLongTypeNameThatWillBreak,
)

type t = constr<(string, int, float)>

type t = constr<(
  superLongTypeNameThatWillBreak,
  superLongTypeNameThatWillBreak,
  superLongTypeNameThatWillBreak,
  superLongTypeNameThatWillBreak,
  superLongTypeNameThatWillBreak,
  superLongTypeNameThatWillBreak,
)>

external foo: (string, int, float) = \\"external_binding\\"

external foo: (
  superLongTypeNameThatWillBreak,
  superLongTypeNameThatWillBreak,
  superLongTypeNameThatWillBreak,
  superLongTypeNameThatWillBreak,
  superLongTypeNameThatWillBreak,
  superLongTypeNameThatWillBreak,
) = \\"external_binding\\"

let x: (int, int) = (1, 2)

let x: (
  superLongTypeNameThatWillBreak,
  superLongTypeNameThatWillBreak,
  superLongTypeNameThatWillBreak,
  superLongTypeNameThatWillBreak,
  superLongTypeNameThatWillBreak,
  superLongTypeNameThatWillBreak,
) = (1, 2)

type t = @attr (@attr string, @attr int, @attr float)
"
`;

exports[`typeConstr.js 1`] = `
"type t = Option.t<string>
type t = Mod.Sub.t<a, b, c>
type t = Mod.Sub.t<
  soooooLoooooong,
  soooooLoooooong,
  soooooLoooooong,
  soooooLoooooong,
  soooooLoooooong,
  soooooLoooooong,
  b,
  c,
>

type t = Mod.Sub.t<
  Mod.Sub.t<soooooLoooooong, soooooLoooooong, soooooLoooooong>,
  soooooLoooooong,
  soooooLoooooong,
  soooooLoooooong,
  b,
  c,
>
type t = Mod.Sub.t<
  Mod.Sub.t<
    soooooLoooooong,
    soooooLoooooong,
    soooooLoooooong,
    soooooLoooooong,
    soooooLoooooong,
  >,
  Nested.Module.t<string, float>,
  soooooLoooooong,
  soooooLoooooong,
  b,
  c,
>

let t: list<{\\"age\\": int}> = x

let t: list<{
  \\"age\\": int,
  \\"name\\": string,
  \\"moreFields\\": veryVeryVeryLongtype,
  \\"superLongNameThat\\": whyDoesATypeWithThisAmountOfCharactersMakeItIntoThisFile,
  \\"because\\": testingLineBreaks,
}> = x

let t: list<
  {\\"age\\": int, @attr \\"name\\": string},
  {\\"name\\": string, @attr \\"age\\": int},
  {\\"name\\": string, @attr \\"age\\": int},
> = x

type t = Option.t<(tupleTyp1, tupleTyp2, tupleTyp3)>
type t = Option.t<(
  tupleTyp1,
  tupleTyp2,
  tupleTyp3,
  tupleTyp3,
  tupleTyp3,
  tupleTyp3,
  tupleTyp3,
  tupleTyp3,
  tupleTyp3,
  tupleTyp3,
)>
let t: Option.t<(
  tupleTyp1,
  tupleTyp2,
  tupleTyp3,
  tupleTyp3,
  tupleTyp3,
  tupleTyp3,
  tupleTyp3,
  tupleTyp3,
  tupleTyp3,
  tupleTyp3,
  tupleTyp3,
  tupleTyp3,
)> = x

type t = @attrs Option.t<string>

let t: @attrs list<{\\"age\\": int}> = x

external color: @attr colour<'t> = \\"c_color\\"

@send @return(nullable)
external getAttribute: (Js.t<'a>, string) => option<string> = \\"getAttribute\\"

let dangerousHtml: string => Js.t<'a> = html => {\\"__html\\": html}
"
`;

exports[`var.js 1`] = `
"type t = 'a
type t = @attr 'a

type t = constr<'a>

external foo: 'foo = \\"primitive\\"
external foo: @attr 'foo = \\"primitive\\"

let x: 'a = y
let x: @attr 'a = y

type x<'A> = 'A
"
`;

exports[`variant.js 1`] = `
"type rgb = [#Red | #Green | #Blue]
type color = [rgb | #Orange | #Yellow | #Purple]

type t = [#variant]
type t = [#Variant]
type t = [#\\"type\\"]
type t = [#\\"va r ia nt\\"]
type t = [#\\"Variant ⛰\\"]

let id = (x: [> #Red | #Green | #Blue]) => x
let upper = (x: [< #Red | #Green]) => true
type point = [#Point(float, float)]
type \\\\\\"type\\" = [#\\"Point🗿\\"(\\\\\\"let\\", float)]
type shape = [
  | #Rectangle(point, point)
  | #Circle(point, float)
]

type madness = [< #\\"type\\" & (\\\\\\"let\\") & (\\\\\\"Super exotic\\") | #\\"Bad Idea\\"]

let error_of_exn: exn => option<[#Ok(error) | #Already_displayed]> = x

external make: (
  ~_type: @string
  [
    | #basis
    | #basisClosed
    | #basisOpen
    | #linear
    | #linearClosed
    | #natural
    | #monotoneX
    | #monotoneY
    | #monotone
    | #step
    | #stepBefore
    | #stepAfter
  ]=?,
  ~dataKey: Config.dataItem => Js.null<yValue>,
  ~stroke: string=?,
  ~strokeWidth: float=?,
  ~strokeDasharray: string=?,
  ~children: React.element=?,
  ~dot: Dot.t=?,
  ~activeDot: Dot.t=?,
  ~label: string=?,
  ~name: string=?,
  ~connectNulls: bool=?,
) => React.element = \\"Line\\"

type empty_conj = X([< #X & ('a) & (int, float)]): empty_conj

type conj = X([< #X(int) & ([< #B(int) & (float)])]): conj

module type Conjunctive = {
  type u1 = [#A | #B]
  type u2 = [#A | #B | #C]

  let f: [< #T([< u2]) & ([< u2]) & ([< u1])] => unit
  let g: [< #S & ([< u2]) & ([< u2]) & ([< u1])] => unit
}

type x = [
  | #Fooooooooooooooooooooooooooooooooooooooo
  | #Baaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaar
  | #Baaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaz
]

type animation = [
  | #\\"ease-in\\"
  | #\\"ease-out\\"
  | #\\"never ease ✍️\\"
]

module type Conjunctive = {
  type u1 = [#A | #B]
  type u2 = [#A | #B | #C]

  let f: [< #T([< u2]) & ([< u2]) & ([< u1])] => unit
  let g: [< #S & ([< u2]) & ([< u2]) & ([< u1])] => unit
  let g: [<
    | #\\"Exotic-S+\\"
    & ([< #\\"Exotic-u2+\\"])
    & ([< #\\"Exotic-u2-\\"])
    & ([< #\\"Exotic-u1+++\\"])
  ] => unit
}

// should break because user wrote it over serveral lines
type currencyPoly = [
  | #USD
  | #CAD
  | #EUR
]

// should not break, user wrote it on one line
type currencyPoly = [#USD | #CAD | #EUR]
//
// should break, line length exceeded
type currencyPoly = [
  | #UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUSD
  | #CAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD
  | #EUUUUUUUUUUUUUUUUUUUR
]

type t = [s]
type t = [ListStyleType.t]
"
`;
